#### 동시성 이슈  

@see com.yoon.StockServiceTest#concurrency_100()
* raceCondition 발생으로 테스트 실패
* 둘 이상의 스레드가 공유 데이터에 접근할 수 있고 동시에 변경을 하려고 할 때 발생하는 이슈
* 해결 방법
  * 하나의 스레드가 실행을 완전히 끝냈을 때까지 다른 스레드가 기다리면된다.
  * 즉, 데이터가 한 개의 스레드만 접근하면된다.


* `synchronized` 를 이용하여 해당 메소드에 하나의 스레드씩 접근할 수 있도록 해보자. 
```java
@Service
public class StockService {

    @Transactional
    public synchronized void decrease(Long id, Long quantity) {
        Stock stock = stockRepository.findById(id).orElseThrow();
        stock.decrease(quantity);
    }
    
}
```


* 이렇게 해도 실패하는데 그 이유는, **스프링 트랜잭션의 작동 방식** 때문.
* @see com.yoon.TransactionStockService#decrease() 를 참조하면 트랜잭션은 프록시 객체를 생성하여 해당 메소드를 실행한다.
* 데이터가 db 에 update 되는 시점은 decrease 메소드가 실행된 이후인데, 그 전에 다른 스레드가 decrease 메소드에 접근할 수 있음.
* 이렇게 되면 기존과 같은 raceCondition 이 발생한다. 
* @Transactional 을 제거한 뒤, 다시 실행해보면 성공하는 이유가 설명됨. 

